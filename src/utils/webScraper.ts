import { ProjectStructure, PageInfo, ComponentInfo, DataModelInfo, WorkflowInfo } from "@/types/project";

export interface ScrapingOptions {
  includeAssets?: boolean;
  includeStyles?: boolean;
  maxDepth?: number;
  followLinks?: boolean;
}

export const scrapeProject = async (url: string, options: ScrapingOptions = {}): Promise<ProjectStructure> => {
  try {
    console.log(`Starting real project analysis for: ${url}`);
    
    // Use browser fetch to get the content directly
    const response = await fetch(url, {
      method: 'GET',
      mode: 'cors',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch: ${response.statusText}`);
    }

    const html = await response.text();
    console.log(`Successfully fetched ${html.length} characters from ${url}`);
    
    return parseScrapedData(html, url);
  } catch (error) {
    console.error('Direct fetch failed due to CORS, using fallback analysis:', error);
    return await browserBasedAnalysis(url);
  }
};

const parseScrapedData = (html: string, url: string): ProjectStructure => {
  const projectName = extractProjectName(extractTitleFromHtml(html) || url);
  
  return {
    id: `scraped_${Date.now()}`,
    name: projectName,
    url,
    sourceType: determineSourceType(url, html),
    pages: extractPagesFromHtml(html, url),
    components: extractComponentsFromHtml(html),
    dataModels: extractDataModelsFromHtml(html),
    workflows: extractWorkflowsFromHtml(html),
    createdAt: new Date(),
    confidence: calculateConfidenceFromHtml(html)
  };
};

const extractTitleFromHtml = (html: string): string => {
  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  return titleMatch ? titleMatch[1].trim() : 'Unknown Project';
};

const extractProjectName = (title: string): string => {
  return title
    .replace(/\s*-\s*.*$/, '')
    .replace(/\s*\|\s*.*$/, '')
    .trim() || 'Analyzed Project';
};

const determineSourceType = (url: string, html: string): 'lovable' | 'other' => {
  if (url.includes('lovable.dev') || url.includes('lovable.app')) {
    return 'lovable';
  }
  if (html.includes('lovable') || html.includes('Generated by Lovable')) {
    return 'lovable';
  }
  return 'other';
};

const extractPagesFromHtml = (html: string, url: string): PageInfo[] => {
  const pages: PageInfo[] = [];
  const routes = new Set<string>();
  
  // Extract React Router routes
  const routeMatches = html.match(/(?:path|to)=["']([^"']+)["']/g) || [];
  routeMatches.forEach(match => {
    const route = match.match(/["']([^"']+)["']/)?.[1];
    if (route && route.startsWith('/') && !route.includes('.')) {
      routes.add(route);
    }
  });
  
  // Extract navigation links
  const linkMatches = html.match(/<a[^>]+href=["']([^"'#][^"']*)["']/g) || [];
  linkMatches.forEach(match => {
    const href = match.match(/href=["']([^"']+)["']/)?.[1];
    if (href && href.startsWith('/') && !href.includes('.') && !href.startsWith('//')) {
      routes.add(href);
    }
  });
  
  // Convert routes to pages
  routes.forEach(route => {
    const name = route === '/' ? 'Home' : 
                 route.split('/').filter(Boolean).map(s => 
                   s.charAt(0).toUpperCase() + s.slice(1)
                 ).join(' ');
    pages.push({
      name,
      path: route,
      components: extractComponentsOnPage(html, route)
    });
  });
  
  if (pages.length === 0) {
    pages.push({ name: 'Home', path: '/', components: ['App'] });
  }
  
  return pages;
};

const extractComponentsFromHtml = (html: string): ComponentInfo[] => {
  const components: ComponentInfo[] = [];
  const uniqueComponents = new Set<string>();
  
  // Extract React components from HTML tags
  const componentMatches = html.match(/<([A-Z][a-zA-Z0-9]*)/g) || [];
  componentMatches.forEach(match => {
    const name = match.slice(1);
    if (name && name.length > 1) {
      uniqueComponents.add(name);
    }
  });
  
  // Extract from script tags (bundled React)
  const scriptMatches = html.match(/<script[^>]*>(.*?)<\/script>/gs) || [];
  scriptMatches.forEach(script => {
    // Look for function components
    const funcMatches = script.match(/function\s+([A-Z][a-zA-Z0-9]*)/g) || [];
    funcMatches.forEach(match => {
      const name = match.split(/\s+/)[1];
      if (name && name.length > 1) {
        uniqueComponents.add(name);
      }
    });
    
    // Look for const components
    const constMatches = script.match(/const\s+([A-Z][a-zA-Z0-9]*)\s*=/g) || [];
    constMatches.forEach(match => {
      const name = match.match(/const\s+([A-Z][a-zA-Z0-9]*)/)?.[1];
      if (name && name.length > 1) {
        uniqueComponents.add(name);
      }
    });
  });
  
  uniqueComponents.forEach(name => {
    const type: ComponentInfo['type'] = 
      name.toLowerCase().includes('page') ? 'page' :
      ['header', 'footer', 'nav', 'sidebar', 'layout'].some(layout => 
        name.toLowerCase().includes(layout)) ? 'layout' :
      ['button', 'input', 'card', 'modal', 'dialog', 'form'].some(ui => 
        name.toLowerCase().includes(ui)) ? 'ui' : 'custom';
    
    components.push({
      name,
      type,
      props: extractPropsForComponent(html, name),
      dependencies: []
    });
  });
  
  // Ensure we have at least basic components
  if (components.length === 0) {
    components.push({ name: 'App', type: 'page', props: [], dependencies: [] });
  }
  
  return components;
};

const extractComponentsOnPage = (html: string, route: string): string[] => {
  // For now, return basic components that are likely on any page
  return ['App', 'Header', 'Main'];
};

const extractPropsForComponent = (html: string, componentName: string): string[] => {
  const props: string[] = [];
  const pattern = new RegExp(`<${componentName}[^>]*([^>]+)>`, 'g');
  const matches = html.match(pattern) || [];
  
  matches.forEach(match => {
    const propMatches = match.match(/(\w+)=["'][^"']*["']/g) || [];
    propMatches.forEach(prop => {
      const propName = prop.split('=')[0];
      if (propName && !props.includes(propName) && propName !== 'className' && propName !== 'style') {
        props.push(propName);
      }
    });
  });
  
  return props;
};

const extractDataModelsFromHtml = (html: string): DataModelInfo[] => {
  const models: DataModelInfo[] = [];
  
  // Look for API endpoints in JavaScript
  const apiMatches = html.match(/(?:fetch|axios|api).*?["']([^"']*\/api\/[^"']*)["']/g) || [];
  const endpoints = [...new Set(apiMatches.map(match => {
    const url = match.match(/["']([^"']*)["']/)?.[1];
    return url ? url.split('/').pop() : null;
  }).filter(Boolean))];
  
  endpoints.forEach(endpoint => {
    if (endpoint) {
      models.push({
        name: endpoint.charAt(0).toUpperCase() + endpoint.slice(1),
        fields: [
          { name: 'id', type: 'string', required: true },
          { name: 'name', type: 'string', required: true },
          { name: 'createdAt', type: 'date', required: false }
        ]
      });
    }
  });
  
  // Look for form fields to infer data models
  const formMatches = html.match(/<(?:input|select|textarea)[^>]*name=["']([^"']*)["']/g) || [];
  if (formMatches.length > 0) {
    const fields = formMatches.map(match => {
      const name = match.match(/name=["']([^"']*)["']/)?.[1];
      const type = match.includes('type="email"') ? 'email' :
                   match.includes('type="number"') ? 'number' :
                   match.includes('type="date"') ? 'date' : 'string';
      return { name: name || 'field', type, required: match.includes('required') };
    }).filter(field => field.name);
    
    if (fields.length > 0) {
      models.push({
        name: 'FormData',
        fields
      });
    }
  }
  
  return models;
};

const extractWorkflowsFromHtml = (html: string): WorkflowInfo[] => {
  const workflows: WorkflowInfo[] = [];
  
  // Look for forms to identify workflows
  const formMatches = html.match(/<form[^>]*>(.*?)<\/form>/gs) || [];
  formMatches.forEach((form, index) => {
    const hasSubmit = form.includes('type="submit"') || form.includes('onSubmit');
    if (hasSubmit) {
      workflows.push({
        name: `Form Submission ${index + 1}`,
        trigger: 'user_action',
        actions: [
          'validate_input',
          'api_call', 
          'redirect'
        ]
      });
    }
  });
  
  // Look for button click handlers
  const buttonMatches = html.match(/onClick.*?=.*?["'][^"']*["']/g) || [];
  if (buttonMatches.length > 0) {
    workflows.push({
      name: 'Button Interactions',
      trigger: 'user_action',
      actions: [
        'handle_click',
        'update_state'
      ]
    });
  }
  
  return workflows;
};

const calculateConfidenceFromHtml = (html: string): number => {
  let confidence = 0.5; // Base confidence
  
  // Higher confidence for React apps
  if (html.includes('react') || html.includes('React')) confidence += 0.2;
  
  // Higher confidence for structured content
  if (html.includes('component') || html.includes('Component')) confidence += 0.1;
  
  // Higher confidence for routing
  if (html.includes('router') || html.includes('Route')) confidence += 0.1;
  
  // Higher confidence for APIs
  if (html.includes('/api/') || html.includes('fetch(')) confidence += 0.1;
  
  return Math.min(confidence, 1.0);
};

const browserBasedAnalysis = async (url: string): Promise<ProjectStructure> => {
  console.log(`Performing browser-based analysis for: ${url}`);
  
  // Fallback basic analysis
  const urlObj = new URL(url);
  const projectName = urlObj.hostname.split('.')[0] || 'Unknown Project';
  
  return {
    id: `browser_${Date.now()}`,
    name: projectName,
    url,
    sourceType: url.includes('lovable') ? 'lovable' : 'other',
    pages: [
      { name: 'Home', path: '/', components: ['App', 'Header', 'Main'] }
    ],
    components: [
      { name: 'App', type: 'page', props: [], dependencies: [] },
      { name: 'Header', type: 'layout', props: [], dependencies: [] },
      { name: 'Main', type: 'custom', props: [], dependencies: [] }
    ],
    dataModels: [],
    workflows: [],
    createdAt: new Date(),
    confidence: 0.3
  };
};