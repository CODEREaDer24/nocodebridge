import { ProjectStructure } from "@/types/project";

export interface ScrapingOptions {
  includeAssets?: boolean;
  includeStyles?: boolean;
  maxDepth?: number;
  followLinks?: boolean;
}

export const scrapeProject = async (url: string, options: ScrapingOptions = {}): Promise<ProjectStructure> => {
  try {
    console.log(`Starting project analysis for: ${url}`);
    
    // Use the fetch website tool to get the content
    const response = await fetch('/api/scrape-project', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url, options })
    });

    if (!response.ok) {
      throw new Error(`Scraping failed: ${response.statusText}`);
    }

    const scrapedData = await response.json();
    return parseScrapedData(scrapedData, url);
  } catch (error) {
    console.error('Scraping failed, using browser-based analysis:', error);
    return await browserBasedAnalysis(url);
  }
};

const parseScrapedData = (data: any, url: string): ProjectStructure => {
  const projectName = extractProjectName(data.title || url);
  
  return {
    id: `scraped_${Date.now()}`,
    name: projectName,
    url,
    sourceType: determineSourceType(url, data),
    pages: extractPages(data),
    components: extractComponents(data),
    dataModels: extractDataModels(data),
    workflows: extractWorkflows(data),
    createdAt: new Date(),
    confidence: calculateConfidence(data)
  };
};

const extractProjectName = (title: string): string => {
  // Clean up the title to extract a meaningful project name
  return title
    .replace(/\s*-\s*.*$/, '') // Remove everything after first dash
    .replace(/\s*\|\s*.*$/, '') // Remove everything after first pipe
    .trim() || 'Untitled Project';
};

const determineSourceType = (url: string, data: any): 'lovable' | 'other' => {
  if (url.includes('lovable.dev') || url.includes('lovable.app')) {
    return 'lovable';
  }
  
  // Check for Lovable-specific patterns in the HTML
  if (data.html?.includes('lovable') || data.html?.includes('Generated by Lovable')) {
    return 'lovable';
  }
  
  return 'other';
};

const extractPages = (data: any): any[] => {
  const pages = [];
  const html = data.html || '';
  
  // Look for navigation links and routes
  const linkPatterns = [
    /<a[^>]+href=["']([^"']+)["'][^>]*>([^<]+)<\/a>/gi,
    /to=["']([^"']+)["']/gi,
    /path=["']([^"']+)["']/gi
  ];
  
  const foundRoutes = new Set<string>();
  
  linkPatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(html)) !== null) {
      const route = match[1];
      if (route && route.startsWith('/') && !route.includes('.') && !route.startsWith('//')) {
        foundRoutes.add(route);
      }
    }
  });
  
  // Convert routes to page objects
  foundRoutes.forEach(route => {
    const pageName = route === '/' ? 'Home' : 
                    route.split('/').filter(Boolean).map(segment => 
                      segment.charAt(0).toUpperCase() + segment.slice(1)
                    ).join(' ');
    
    pages.push({
      name: pageName,
      path: route,
      components: extractComponentsForRoute(html, route)
    });
  });
  
  // Ensure we have at least a home page
  if (pages.length === 0) {
    pages.push({
      name: 'Home',
      path: '/',
      components: ['App', 'Header', 'Main', 'Footer']
    });
  }
  
  return pages;
};

const extractComponents = (data: any): any[] => {
  const html = data.html || '';
  const components = [];
  
  // Extract React component names from JSX-like patterns
  const componentPattern = /<([A-Z][a-zA-Z0-9]*)/g;
  const foundComponents = new Set<string>();
  
  let match;
  while ((match = componentPattern.exec(html)) !== null) {
    foundComponents.add(match[1]);
  }
  
  // Also look for component definitions
  const definitionPatterns = [
    /(?:function|const)\s+([A-Z][a-zA-Z0-9]*)/g,
    /class\s+([A-Z][a-zA-Z0-9]*)/g,
    /export\s+(?:default\s+)?(?:function\s+)?([A-Z][a-zA-Z0-9]*)/g
  ];
  
  definitionPatterns.forEach(pattern => {
    let defMatch;
    while ((defMatch = pattern.exec(html)) !== null) {
      foundComponents.add(defMatch[1]);
    }
  });
  
  foundComponents.forEach(componentName => {
    const type = categorizeComponent(componentName);
    const props = extractComponentProps(html, componentName);
    
    components.push({
      name: componentName,
      type,
      props: props.length > 0 ? props : undefined
    });
  });
  
  return components;
};

const categorizeComponent = (name: string): 'ui' | 'page' | 'layout' | 'custom' => {
  const lowerName = name.toLowerCase();
  
  if (['header', 'footer', 'sidebar', 'navigation', 'nav', 'layout'].some(layout => 
      lowerName.includes(layout))) {
    return 'layout';
  }
  
  if (['button', 'input', 'form', 'modal', 'dialog', 'card', 'table', 'list'].some(ui => 
      lowerName.includes(ui))) {
    return 'ui';
  }
  
  if (['page', 'home', 'about', 'contact', 'dashboard', 'profile'].some(page => 
      lowerName.includes(page))) {
    return 'page';
  }
  
  return 'custom';
};

const extractComponentProps = (html: string, componentName: string): string[] => {
  const props = new Set<string>();
  
  // Find all usages of this component
  const usagePattern = new RegExp(`<${componentName}([^>]*)>`, 'g');
  let match;
  
  while ((match = usagePattern.exec(html)) !== null) {
    const attributes = match[1];
    
    // Extract prop names
    const propPattern = /\s([a-zA-Z][a-zA-Z0-9]*?)=/g;
    let propMatch;
    
    while ((propMatch = propPattern.exec(attributes)) !== null) {
      const propName = propMatch[1];
      if (!['key', 'ref', 'className', 'style', 'id'].includes(propName)) {
        props.add(propName);
      }
    }
  }
  
  return Array.from(props);
};

const extractComponentsForRoute = (html: string, route: string): string[] => {
  // This is a simplified approach - in a real implementation,
  // you'd need more sophisticated routing analysis
  const basicComponents = ['Header', 'Footer'];
  
  if (route === '/') {
    basicComponents.push('Hero', 'Main');
  } else {
    const routeName = route.split('/').filter(Boolean).map(segment => 
      segment.charAt(0).toUpperCase() + segment.slice(1)
    ).join('');
    if (routeName) {
      basicComponents.push(routeName);
    }
  }
  
  return basicComponents;
};

const extractDataModels = (data: any): any[] => {
  const html = data.html || '';
  const models = [];
  
  // Look for TypeScript interfaces and types
  const interfacePattern = /interface\s+(\w+)\s*{([^}]+)}/g;
  const typePattern = /type\s+(\w+)\s*=\s*{([^}]+)}/g;
  
  [interfacePattern, typePattern].forEach(pattern => {
    let match;
    while ((match = pattern.exec(html)) !== null) {
      const name = match[1];
      const body = match[2];
      
      const fields = parseTypeFields(body);
      if (fields.length > 0) {
        models.push({ name, fields });
      }
    }
  });
  
  return models;
};

const parseTypeFields = (body: string): any[] => {
  const fields = [];
  const lines = body.split(/[;\n,]/).map(line => line.trim()).filter(Boolean);
  
  lines.forEach(line => {
    const match = line.match(/(\w+)(\?)?:\s*(\w+)/);
    if (match) {
      fields.push({
        name: match[1],
        type: match[3],
        required: !match[2]
      });
    }
  });
  
  return fields;
};

const extractWorkflows = (data: any): any[] => {
  const html = data.html || '';
  const workflows = [];
  
  // Detect common patterns
  if (html.includes('onSubmit') || html.includes('handleSubmit')) {
    workflows.push({
      name: 'Form Processing',
      trigger: 'Form submission',
      actions: ['Validate input', 'Submit data', 'Handle response'],
      description: 'Processes form submissions and user input'
    });
  }
  
  if (html.includes('onClick') || html.includes('handleClick')) {
    workflows.push({
      name: 'User Interaction',
      trigger: 'User clicks and interactions',
      actions: ['Handle event', 'Update state', 'Trigger effects'],
      description: 'Manages user interface interactions and state changes'
    });
  }
  
  if (html.includes('useEffect') || html.includes('fetch') || html.includes('api')) {
    workflows.push({
      name: 'Data Fetching',
      trigger: 'Component mount or dependency changes',
      actions: ['Fetch data', 'Update state', 'Handle errors'],
      description: 'Manages data fetching and API interactions'
    });
  }
  
  return workflows;
};

const calculateConfidence = (data: any): number => {
  let confidence = 0.5; // Base confidence
  
  // Increase confidence based on available data
  if (data.title) confidence += 0.1;
  if (data.html && data.html.length > 1000) confidence += 0.1;
  if (data.html?.includes('React')) confidence += 0.1;
  if (data.html?.includes('component')) confidence += 0.1;
  if (data.html?.includes('useState') || data.html?.includes('useEffect')) confidence += 0.1;
  
  return Math.min(confidence, 0.95);
};

const browserBasedAnalysis = async (url: string): Promise<ProjectStructure> => {
  // Fallback analysis when scraping fails
  const urlObj = new URL(url);
  const projectName = urlObj.hostname.split('.')[0] || 'Unknown Project';
  
  return {
    id: `browser_${Date.now()}`,
    name: projectName,
    url,
    sourceType: url.includes('lovable') ? 'lovable' : 'other',
    pages: [
      { name: 'Home', path: '/', components: ['App', 'Header', 'Main', 'Footer'] }
    ],
    components: [
      { name: 'App', type: 'page' },
      { name: 'Header', type: 'layout' },
      { name: 'Main', type: 'layout' },
      { name: 'Footer', type: 'layout' }
    ],
    dataModels: [],
    workflows: [],
    createdAt: new Date(),
    confidence: 0.3 // Low confidence for fallback
  };
};