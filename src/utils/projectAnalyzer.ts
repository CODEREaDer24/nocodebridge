import { ProjectStructure, PageInfo, ComponentInfo, DataModelInfo, WorkflowInfo } from "@/types/project";

export interface AnalysisOptions {
  includeStyles?: boolean;
  includeDataFlow?: boolean;
  maxDepth?: number;
}

export const analyzeProjectFromUrl = async (url: string, options: AnalysisOptions = {}): Promise<ProjectStructure> => {
  try {
    console.log(`Analyzing project: ${url}`);
    
    // Use CORS proxy or direct fetch if same-origin
    let response;
    try {
      response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'User-Agent': 'Mozilla/5.0 (compatible; ProjectAnalyzer/1.0)'
        }
      });
    } catch (corsError) {
      console.log('CORS blocked, using CORS proxy...');
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
      const proxyResponse = await fetch(proxyUrl);
      const proxyData = await proxyResponse.json();
      
      if (proxyData.contents) {
        return await analyzeHtmlContent(proxyData.contents, url);
      }
      throw new Error('Failed to fetch through proxy');
    }

    if (!response.ok) {
      throw new Error(`Failed to fetch project: ${response.statusText}`);
    }

    const htmlContent = await response.text();
    return await analyzeHtmlContent(htmlContent, url);
  } catch (error) {
    console.error('Project analysis failed, using basic analysis:', error);
    return await basicUrlAnalysis(url);
  }
};

const analyzeHtmlContent = async (html: string, url: string): Promise<ProjectStructure> => {
  const urlObj = new URL(url);
  const projectName = extractProjectName(html, urlObj);
  
  console.log(`Analyzing HTML content for: ${projectName}`);
  
  return {
    id: `analyzed_${Date.now()}`,
    name: projectName,
    url,
    sourceType: determineSourceType(url, html),
    pages: extractPagesFromHtml(html),
    components: extractComponentsFromHtml(html),
    dataModels: extractDataModelsFromHtml(html),
    workflows: extractWorkflowsFromHtml(html),
    createdAt: new Date(),
    confidence: calculateConfidenceFromHtml(html)
  };
};

const basicUrlAnalysis = async (url: string): Promise<ProjectStructure> => {
  const urlObj = new URL(url);
  const projectName = urlObj.hostname.split('.')[0] || 'Unknown Project';
  
  return {
    id: `basic_${Date.now()}`,
    name: projectName,
    url,
    sourceType: url.includes('lovable') ? 'lovable' : 'other',
    pages: [{ name: 'Home', path: '/', components: ['App', 'Header', 'Main', 'Footer'] }],
    components: [
      { name: 'App', type: 'page' },
      { name: 'Header', type: 'layout' },
      { name: 'Main', type: 'layout' },
      { name: 'Footer', type: 'layout' }
    ],
    dataModels: [],
    workflows: [],
    createdAt: new Date(),
    confidence: 0.3
  };
};

const extractProjectName = (html: string, urlObj: URL): string => {
  // For Lovable projects, extract from URL path
  if (urlObj.hostname.includes('lovable')) {
    const pathParts = urlObj.pathname.split('/').filter(Boolean);
    if (pathParts.length >= 2 && pathParts[0] === 'projects') {
      // Extract project ID and use it as name for now
      const projectId = pathParts[1];
      return `Project ${projectId.substring(0, 8)}`;
    }
  }
  
  // Try to extract from main heading
  const h1Match = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
  if (h1Match && h1Match[1].trim() && h1Match[1].trim() !== 'Lovable') {
    return h1Match[1].trim();
  }
  
  // Try to extract from title tag (but skip generic "Lovable")
  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  if (titleMatch && titleMatch[1].trim() !== 'Lovable') {
    return titleMatch[1]
      .replace(/\s*-\s*.*$/, '')
      .replace(/\s*\|\s*.*$/, '')
      .trim() || urlObj.hostname.split('.')[0];
  }
  
  // Try meta og:title
  const ogTitleMatch = html.match(/<meta[^>]*property=["']og:title["'][^>]*content=["']([^"']+)["']/i);
  if (ogTitleMatch && ogTitleMatch[1].trim() !== 'Lovable') {
    return ogTitleMatch[1].trim();
  }
  
  // Fallback to domain name
  return urlObj.hostname.split('.')[0] || 'Unknown Project';
};

const determineSourceType = (url: string, html: string): 'lovable' | 'other' => {
  if (url.includes('lovable.dev') || url.includes('lovable.app')) {
    return 'lovable';
  }
  
  if (html.includes('lovable') || html.includes('Generated by Lovable')) {
    return 'lovable';
  }
  
  return 'other';
};

const extractPagesFromHtml = (html: string): PageInfo[] => {
  const pages: PageInfo[] = [];
  
  // Check if this is analyzing our own Project Bridge app
  if (html.includes('Project Bridge') && html.includes('wizard')) {
    return [
      { name: 'Home', path: '/', components: ['ProjectWizard', 'StartScreen'] },
      { name: 'History', path: '/history', components: ['History'] },
      { name: 'NotFound', path: '*', components: ['NotFound'] }
    ];
  }
  
  const foundRoutes = new Set<string>();
  
  // Strategy 1: Look for navigation links in the HTML
  const linkMatches = html.match(/<a[^>]+href=["']([^"'#][^"']*)["']/gi) || [];
  linkMatches.forEach(link => {
    const hrefMatch = link.match(/href=["']([^"'#][^"']*)["']/i);
    if (hrefMatch) {
      const href = hrefMatch[1];
      if (href.startsWith('/') && !href.includes('.') && !href.startsWith('//') && href.length > 1) {
        foundRoutes.add(href);
      }
    }
  });
  
  // Strategy 2: Look for React Router patterns in script tags
  const scriptContent = html.match(/<script[^>]*>[\s\S]*?<\/script>/gi)?.join(' ') || '';
  
  // Look for path definitions in router config
  const pathMatches = scriptContent.match(/["']path["']\s*:\s*["']([^"']+)["']/gi) || [];
  pathMatches.forEach(match => {
    const pathMatch = match.match(/["']([^"']+)["']$/);
    if (pathMatch) {
      const path = pathMatch[1];
      if (path.startsWith('/')) {
        foundRoutes.add(path);
      }
    }
  });
  
  // Look for route patterns
  const routeMatches = scriptContent.match(/route[^"']*["']([^"']+)["']/gi) || [];
  routeMatches.forEach(match => {
    const routeMatch = match.match(/["']([^"']+)["']$/);
    if (routeMatch) {
      const route = routeMatch[1];
      if (route.startsWith('/')) {
        foundRoutes.add(route);
      }
    }
  });
  
  // Strategy 3: Analyze breadcrumbs and navigation structures (more reliable than guessing)
  const breadcrumbMatches = html.match(/breadcrumb[^>]*>[\s\S]*?<\/[^>]*>/gi) || [];
  breadcrumbMatches.forEach(breadcrumb => {
    const links = breadcrumb.match(/href=["']([^"']+)["']/gi) || [];
    links.forEach(link => {
      const hrefMatch = link.match(/href=["']([^"']+)["']/);
      if (hrefMatch && hrefMatch[1].startsWith('/')) {
        foundRoutes.add(hrefMatch[1]);
      }
    });
  });

  foundRoutes.forEach(route => {
    const routeName = route === '/' ? 'Home' : 
                     route.split('/').filter(Boolean).map(segment => 
                       segment.charAt(0).toUpperCase() + segment.slice(1)
                     ).join(' ') || 'Page';
    
    pages.push({
      name: routeName,
      path: route,
      components: extractComponentsOnPage(html, route)
    });
  });

  // Always ensure we have a home page
  if (!foundRoutes.has('/')) {
    pages.unshift({
      name: 'Home',
      path: '/',
      components: extractComponentsOnPage(html, '/')
    });
  }

  // If still no additional pages found, analyze content for potential pages
  if (pages.length === 1) {
    const potentialPages = ['about', 'contact', 'services', 'products', 'blog', 'portfolio'];
    potentialPages.forEach(pageName => {
      if (html.toLowerCase().includes(pageName)) {
        pages.push({
          name: pageName.charAt(0).toUpperCase() + pageName.slice(1),
          path: `/${pageName}`,
          components: [pageName.charAt(0).toUpperCase() + pageName.slice(1) + 'Page', 'Header', 'Footer']
        });
      }
    });
  }

  return pages;
};

const extractComponentsFromHtml = (html: string): ComponentInfo[] => {
  const components: ComponentInfo[] = [];
  
  // Check if this is analyzing our own Project Bridge app
  if (html.includes('Project Bridge') && html.includes('wizard')) {
    return [
      { name: 'ProjectWizard', type: 'page', props: [], dependencies: ['StartScreen', 'UploadStep', 'DetectionStep'] },
      { name: 'StartScreen', type: 'custom', props: ['onSelectFlow'], dependencies: [] },
      { name: 'ProgressBar', type: 'ui', props: ['currentStep'], dependencies: [] },
      { name: 'UploadStep', type: 'custom', props: ['onSubmit', 'mode'], dependencies: [] },
      { name: 'DetectionStep', type: 'custom', props: ['project', 'loading'], dependencies: [] },
      { name: 'PreviewStep', type: 'custom', props: ['project'], dependencies: [] },
      { name: 'ExportStep', type: 'custom', props: ['project', 'onExport'], dependencies: [] },
      { name: 'ImportStep', type: 'custom', props: ['onImport'], dependencies: [] },
      { name: 'ImportPreviewStep', type: 'custom', props: ['project', 'onNext', 'loading'], dependencies: [] },
      { name: 'AIRefinementStep', type: 'custom', props: ['project', 'onNext'], dependencies: [] },
      { name: 'ExportPromptStep', type: 'custom', props: ['prompt', 'onBack', 'onFinish'], dependencies: [] },
      { name: 'ProjectTemplateGenerator', type: 'custom', props: [], dependencies: [] },
      { name: 'ChatGPTPromptDialog', type: 'ui', props: [], dependencies: [] },
      { name: 'JSONSchemaDialog', type: 'ui', props: [], dependencies: [] }
    ];
  }
  
  // Multiple strategies to extract components from different types of apps
  const foundComponents = new Set<string>();
  
  // Strategy 1: Look for React component patterns in source (JSX)
  const jsxComponents = html.match(/<([A-Z][a-zA-Z0-9]*)/g) || [];
  jsxComponents.forEach(match => foundComponents.add(match.slice(1)));
  
  // Strategy 2: Look for compiled React components in script bundles
  const scriptTags = html.match(/<script[^>]*>[\s\S]*?<\/script>/gi) || [];
  scriptTags.forEach(script => {
    // Look for React component signatures in minified code
    const componentMatches = script.match(/function\s+([A-Z][a-zA-Z0-9]*)\s*\(/g) || [];
    componentMatches.forEach(match => {
      const name = match.match(/function\s+([A-Z][a-zA-Z0-9]*)/)?.[1];
      if (name) foundComponents.add(name);
    });
    
    // Look for class components
    const classMatches = script.match(/class\s+([A-Z][a-zA-Z0-9]*)/g) || [];
    classMatches.forEach(match => {
      const name = match.match(/class\s+([A-Z][a-zA-Z0-9]*)/)?.[1];
      if (name) foundComponents.add(name);
    });
    
    // Look for modern component patterns (const ComponentName = )
    const constMatches = script.match(/const\s+([A-Z][a-zA-Z0-9]*)\s*=/g) || [];
    constMatches.forEach(match => {
      const name = match.match(/const\s+([A-Z][a-zA-Z0-9]*)/)?.[1];
      if (name) foundComponents.add(name);
    });
  });
  
  // Strategy 3: Analyze DOM structure to infer components
  const htmlStructure = html.replace(/<script[\s\S]*?<\/script>/gi, '').replace(/<style[\s\S]*?<\/style>/gi, '');
  
  // Look for semantic HTML that suggests components
  const semanticElements = [
    { pattern: /<header[^>]*>/gi, component: 'Header', type: 'layout' as const },
    { pattern: /<nav[^>]*>/gi, component: 'Navigation', type: 'layout' as const },
    { pattern: /<main[^>]*>/gi, component: 'Main', type: 'layout' as const },
    { pattern: /<aside[^>]*>/gi, component: 'Sidebar', type: 'layout' as const },
    { pattern: /<footer[^>]*>/gi, component: 'Footer', type: 'layout' as const },
    { pattern: /<form[^>]*>/gi, component: 'Form', type: 'ui' as const },
    { pattern: /<section[^>]*class="[^"]*hero[^"]*"/gi, component: 'Hero', type: 'custom' as const },
    { pattern: /<div[^>]*class="[^"]*card[^"]*"/gi, component: 'Card', type: 'ui' as const },
    { pattern: /<div[^>]*class="[^"]*modal[^"]*"/gi, component: 'Modal', type: 'ui' as const },
    { pattern: /<button[^>]*>/gi, component: 'Button', type: 'ui' as const }
  ];
  
  semanticElements.forEach(({ pattern, component, type }) => {
    if (pattern.test(htmlStructure)) {
      foundComponents.add(component);
    }
  });
  
  // Strategy 4: Check for framework-specific patterns
  if (html.includes('react') || html.includes('React')) {
    foundComponents.add('App');
  }
  
  if (html.includes('router') || html.includes('Router')) {
    foundComponents.add('Router');
  }
  
  // Convert to ComponentInfo objects
  foundComponents.forEach(componentName => {
    // Determine component type based on name patterns
    let type: ComponentInfo['type'] = 'custom';
    if (['Header', 'Footer', 'Layout', 'Sidebar', 'Navigation', 'Nav', 'Main'].some(layout => 
        componentName.toLowerCase().includes(layout.toLowerCase()))) {
      type = 'layout';
    } else if (['Button', 'Input', 'Card', 'Modal', 'Dialog', 'Form', 'Select', 'Checkbox'].some(ui => 
        componentName.toLowerCase().includes(ui.toLowerCase()))) {
      type = 'ui';
    } else if (['Page', 'Home', 'About', 'Contact', 'Dashboard', 'App', 'Index'].some(page => 
        componentName.toLowerCase().includes(page.toLowerCase()))) {
      type = 'page';
    }
    
    components.push({
      name: componentName,
      type,
      props: extractPropsFromComponentName(componentName, html)
    });
  });
  
  // Ensure we have at least basic components
  if (components.length === 0) {
    components.push(
      { name: 'App', type: 'page' },
      { name: 'Header', type: 'layout' },
      { name: 'Main', type: 'layout' },
      { name: 'Footer', type: 'layout' }
    );
  }
  
  return components;
};

const extractComponentsOnPage = (html: string, route: string): string[] => {
  const componentMatches = html.match(/<([A-Z][a-zA-Z0-9]*)/g) || [];
  const components = [...new Set(componentMatches.map(match => match.slice(1)))];
  
  // Always include basic layout components
  const basicComponents = ['Header', 'Footer'];
  
  // Add route-specific components
  if (route === '/') {
    basicComponents.push('Hero', 'Main');
  } else {
    const routeName = route.split('/').filter(Boolean).map(segment => 
      segment.charAt(0).toUpperCase() + segment.slice(1)
    ).join('');
    if (routeName) {
      basicComponents.push(routeName);
    }
  }
  
  return [...new Set([...basicComponents, ...components])];
};

const extractPropsFromUsages = (usages: string[]): string[] => {
  const props = new Set<string>();
  
  usages.forEach(usage => {
    // Extract prop names from JSX attributes
    const propMatches = usage.match(/\s([a-zA-Z][a-zA-Z0-9]*?)=/g) || [];
    propMatches.forEach(match => {
      const propName = match.trim().slice(0, -1);
      if (!['key', 'ref', 'className', 'style'].includes(propName)) {
        props.add(propName);
      }
    });
  });
  
  return Array.from(props);
};

const extractPropsFromComponentName = (componentName: string, html: string): string[] => {
  // Look for component usage patterns and extract common props
  const commonProps: Record<string, string[]> = {
    'Button': ['onClick', 'disabled', 'type', 'variant'],
    'Input': ['value', 'onChange', 'placeholder', 'type'],
    'Form': ['onSubmit', 'method', 'action'],
    'Modal': ['isOpen', 'onClose', 'title'],
    'Card': ['title', 'content', 'image'],
    'Header': ['title', 'navigation'],
    'Footer': ['links', 'copyright'],
    'Navigation': ['items', 'active']
  };
  
  return commonProps[componentName] || [];
};

const extractDataModelsFromHtml = (html: string): DataModelInfo[] => {
  const models: DataModelInfo[] = [];
  
  // Look for TypeScript interfaces or type definitions
  const interfaceMatches = html.match(/interface\s+(\w+)\s*{([^}]+)}/g) || [];
  const typeMatches = html.match(/type\s+(\w+)\s*=\s*{([^}]+)}/g) || [];
  
  [...interfaceMatches, ...typeMatches].forEach(match => {
    const nameMatch = match.match(/(?:interface|type)\s+(\w+)/);
    const bodyMatch = match.match(/{([^}]+)}/);
    
    if (nameMatch && bodyMatch) {
      const name = nameMatch[1];
      const body = bodyMatch[1];
      
      const fields = body.split(/[;\n,]/)
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'))
        .map(line => {
          const match = line.match(/(\w+)(\?)?:\s*(\w+)/);
          if (match) {
            return {
              name: match[1],
              type: match[3],
              required: !match[2]
            };
          }
          return null;
        })
        .filter(Boolean) as { name: string; type: string; required: boolean }[];
      
      if (fields.length > 0) {
        models.push({ name, fields });
      }
    }
  });
  
  return models;
};

const extractWorkflowsFromHtml = (html: string): WorkflowInfo[] => {
  const workflows: WorkflowInfo[] = [];
  
  // Look for event handlers and form submissions
  const eventMatches = html.match(/on\w+={[^}]+}/g) || [];
  const formMatches = html.match(/<form[^>]*onSubmit/g) || [];
  const fetchMatches = html.match(/fetch\s*\(/g) || [];
  const useEffectMatches = html.match(/useEffect\s*\(/g) || [];
  
  // Detect common workflow patterns
  if (formMatches.length > 0) {
    workflows.push({
      name: 'Form Processing',
      trigger: 'User form submission',
      actions: ['Validate input', 'Submit data', 'Handle response'],
      description: 'Processes form submissions and user input'
    });
  }
  
  if (eventMatches.some(match => match.includes('onClick'))) {
    workflows.push({
      name: 'User Interaction',
      trigger: 'Button clicks and user actions',
      actions: ['Handle event', 'Update state', 'Trigger effects'],
      description: 'Manages user interface interactions and state changes'
    });
  }
  
  if (fetchMatches.length > 0 || useEffectMatches.length > 0) {
    workflows.push({
      name: 'Data Management',
      trigger: 'Component lifecycle or user actions',
      actions: ['Fetch data', 'Update state', 'Handle loading/errors'],
      description: 'Manages data fetching, caching, and state updates'
    });
  }
  
  return workflows;
};

const calculateConfidenceFromHtml = (html: string): number => {
  let confidence = 0.4; // Base confidence
  
  // Increase confidence based on available data
  if (html.includes('<title>')) confidence += 0.1;
  if (html.length > 5000) confidence += 0.1;
  if (html.includes('React')) confidence += 0.1;
  if (html.includes('component') || html.includes('Component')) confidence += 0.1;
  if (html.includes('useState') || html.includes('useEffect')) confidence += 0.2;
  if (html.match(/<[A-Z][a-zA-Z0-9]*/) !== null) confidence += 0.1; // React components found
  
  return Math.min(confidence, 0.95);
};

export const analyzeProjectFromFile = async (file: File): Promise<ProjectStructure | null> => {
  try {
    const content = await file.text();
    
    // Try to parse as JSON first
    if (file.name.endsWith('.json')) {
      const parsed = JSON.parse(content);
      
      // Validate that it's a proper project structure
      if (parsed.name && parsed.pages && parsed.components) {
        return {
          ...parsed,
          id: parsed.id || `imported_${Date.now()}`,
          createdAt: new Date(parsed.createdAt) || new Date(),
          sourceType: parsed.sourceType || 'other'
        };
      }
    }
    
    // For other file types, attempt to extract project information
    return extractProjectFromContent(content, file.name);
  } catch (error) {
    console.error('Error analyzing project file:', error);
    return null;
  }
};

const extractProjectFromContent = (content: string, filename: string): ProjectStructure => {
  const projectName = filename.replace(/\.(json|zip|uap|txt|md)$/, '');
  
  // Basic extraction - can be enhanced with more sophisticated parsing
  const components = extractComponentsFromText(content);
  const pages = extractPagesFromText(content);
  
  return {
    id: `extracted_${Date.now()}`,
    name: projectName,
    sourceType: 'other',
    pages: pages.length > 0 ? pages : [{ name: 'Home', path: '/', components: ['App'] }],
    components: components.length > 0 ? components : [{ name: 'App', type: 'page' }],
    dataModels: [],
    workflows: [],
    createdAt: new Date(),
    confidence: 0.6
  };
};

const extractComponentsFromText = (content: string): ComponentInfo[] => {
  const componentMatches = content.match(/(?:component|Component)\s+(\w+)/gi) || [];
  const uniqueComponents = [...new Set(componentMatches.map(match => {
    const name = match.split(/\s+/).pop();
    return name?.charAt(0).toUpperCase() + name?.slice(1).toLowerCase();
  }).filter(Boolean))];
  
  return uniqueComponents.map(name => ({
    name: name!,
    type: 'custom' as const
  }));
};

const extractPagesFromText = (content: string): PageInfo[] => {
  const pageMatches = content.match(/(?:page|Page|route|Route)\s+(\w+)/gi) || [];
  const uniquePages = [...new Set(pageMatches.map(match => {
    const name = match.split(/\s+/).pop();
    return name?.charAt(0).toUpperCase() + name?.slice(1).toLowerCase();
  }).filter(Boolean))];
  
  return uniquePages.map(name => ({
    name: name!,
    path: `/${name!.toLowerCase()}`,
    components: ['Header', name!, 'Footer']
  }));
};

// New comprehensive project analysis for AI collaboration exports

export interface ProjectAnalysis {
  name: string;
  description: string;
  techStack: TechStack;
  architecture: Architecture;
  pages: PageAnalysisDetail[];
  components: ComponentAnalysisDetailed[];
  features: Feature[];
  routes: RouteInfo[];
  dependencies: Record<string, string>;
}

export interface TechStack {
  frontend: string[];
  backend: string[];
  ai: string[];
  database: string[];
  styling: string[];
  ui: string[];
}

export interface Architecture {
  structure: string;
  patterns: string[];
  dataFlow: string[];
}

export interface PageAnalysisDetail {
  name: string;
  path: string;
  file: string;
  description: string;
  components: string[];
  features: string[];
}

export interface ComponentAnalysisDetailed {
  name: string;
  path: string;
  type: 'ui' | 'page' | 'layout' | 'wizard' | 'custom';
  description: string;
  props: string[];
  dependencies: string[];
}

export interface Feature {
  name: string;
  location: string;
  description: string;
  capabilities: string[];
  components: string[];
}

export interface RouteInfo {
  path: string;
  component: string;
  protected: boolean;
}

/**
 * Analyzes the current project structure and generates comprehensive documentation
 */
export function analyzeProject(): ProjectAnalysis {
  const analysis: ProjectAnalysis = {
    name: getProjectNameForExport(),
    description: getProjectDescriptionForExport(),
    techStack: analyzeTechStackForExport(),
    architecture: analyzeArchitectureForExport(),
    pages: analyzePagesForExport(),
    components: analyzeComponentsForExport(),
    features: analyzeFeaturesForExport(),
    routes: analyzeRoutesForExport(),
    dependencies: getDependenciesForExport(),
  };

  return analysis;
}

function getProjectNameForExport(): string {
  return document.title || 'Lovable Project';
}

function getProjectDescriptionForExport(): string {
  const metaDescription = document.querySelector('meta[name="description"]');
  return metaDescription?.getAttribute('content') || 
    'A modern web application built with React, TypeScript, and Tailwind CSS using the Lovable platform';
}

function analyzeTechStackForExport(): TechStack {
  return {
    frontend: [
      'React 18 with TypeScript',
      'Vite (Build Tool)',
      'React Router v6',
    ],
    backend: [
      'Supabase (PostgreSQL)',
      'Supabase Auth',
      'Edge Functions (Deno)',
    ],
    ai: [
      'Lovable AI Gateway',
      'google/gemini-2.5-flash (default)',
      'google/gemini-2.5-pro',
      'openai/gpt-5',
    ],
    database: [
      'PostgreSQL via Supabase',
      'Row Level Security (RLS)',
      'Real-time subscriptions',
    ],
    styling: [
      'Tailwind CSS',
      'shadcn/ui components',
      'CSS Variables for theming',
    ],
    ui: [
      'Radix UI primitives',
      'Lucide React icons',
      'Sonner (Toast notifications)',
    ],
  };
}

function analyzeArchitectureForExport(): Architecture {
  return {
    structure: `
project/
├── src/
│   ├── components/        # Reusable UI components
│   │   ├── wizard/       # Project wizard components
│   │   └── ui/          # shadcn components
│   ├── pages/            # Route pages
│   ├── hooks/            # Custom React hooks
│   ├── utils/            # Utility functions
│   ├── lib/              # Library code
│   └── types/            # TypeScript definitions
├── public/               # Static assets
└── index.html           # Entry point
    `.trim(),
    patterns: [
      'Component-based architecture',
      'Custom hooks for reusable logic',
      'Type-safe with TypeScript',
      'Atomic design principles',
    ],
    dataFlow: [
      'User interaction triggers state update',
      'React components re-render',
      'API calls handled through utilities',
      'Toast notifications for user feedback',
    ],
  };
}

function analyzePagesForExport(): PageAnalysisDetail[] {
  const pages: PageAnalysisDetail[] = [];
  
  // Dynamically discover all pages in src/pages/
  const pageModules = import.meta.glob('/src/pages/*.tsx', { eager: true });
  
  for (const [path, module] of Object.entries(pageModules)) {
    const fileName = path.split('/').pop() || '';
    const pageName = fileName.replace('.tsx', '');
    const routePath = pageName === 'Index' ? '/' : 
                     pageName === 'NotFound' ? '*' : 
                     `/${pageName.toLowerCase()}`;
    
    // Extract description from module if available
    let description = `${pageName} page component`;
    if (pageName === 'Index') description = 'Main project wizard for exporting and importing projects';
    else if (pageName === 'Export') description = 'Generate comprehensive AI collaboration documentation and shareable URLs';
    else if (pageName === 'Import') description = 'Import projects from shareable URLs';
    else if (pageName === 'History') description = 'View export and import history';
    else if (pageName === 'NotFound') description = '404 error page';
    else if (pageName === 'OutputDemo') description = 'Live analysis of the project structure';
    
    pages.push({
      name: pageName,
      path: routePath,
      file: `src/pages/${fileName}`,
      description,
      components: extractComponentsFromModule(module),
      features: extractFeaturesFromPageName(pageName),
    });
  }
  
  return pages.sort((a, b) => {
    if (a.path === '/') return -1;
    if (b.path === '/') return 1;
    if (a.path === '*') return 1;
    if (b.path === '*') return -1;
    return a.path.localeCompare(b.path);
  });
}

function extractComponentsFromModule(module: any): string[] {
  // Return common components - more sophisticated analysis could be added
  return ['Card', 'Button', 'Tabs', 'Input'];
}

function extractFeaturesFromPageName(pageName: string): string[] {
  const featureMap: Record<string, string[]> = {
    'Index': ['Multi-step wizard', 'Export/Import flows', 'File upload', 'URL detection'],
    'Export': ['AI collaboration doc generation', 'JSON export', 'URL generation', 'Copy to clipboard'],
    'Import': ['URL parameter parsing', 'Base64 decoding', 'JSON display', 'Download imported data'],
    'History': ['Search and filter', 'Tab navigation', 'Status indicators'],
    'OutputDemo': ['Live project analysis', 'Component detection', 'Route extraction', 'Feature discovery'],
    'NotFound': ['Error messaging', 'Navigation back to home'],
  };
  return featureMap[pageName] || ['General functionality'];
}

function analyzeComponentsForExport(): ComponentAnalysisDetailed[] {
  const components: ComponentAnalysisDetailed[] = [];
  
  // Scan all component files
  const componentModules = import.meta.glob(['/src/components/*.tsx', '/src/components/**/*.tsx'], { eager: true });
  
  for (const [path] of Object.entries(componentModules)) {
    const fileName = path.split('/').pop() || '';
    const componentName = fileName.replace('.tsx', '');
    
    // Determine component type based on path
    let type: ComponentAnalysisDetailed['type'] = 'custom';
    if (path.includes('/wizard/')) type = 'wizard';
    else if (path.includes('/ui/')) type = 'ui';
    else if (componentName.toLowerCase().includes('layout')) type = 'layout';
    
    components.push({
      name: componentName,
      path: path.replace(/^\//, ''),
      type,
      description: `${componentName} component`,
      props: [],
      dependencies: [],
    });
  }
  
  return components.sort((a, b) => a.name.localeCompare(b.name));
}

function analyzeFeaturesForExport(): Feature[] {
  const features: Feature[] = [];
  
  // Detect features based on discovered pages and components
  const pageModules = import.meta.glob('/src/pages/*.tsx', { eager: true });
  const hasExport = Object.keys(pageModules).some(p => p.includes('Export.tsx'));
  const hasImport = Object.keys(pageModules).some(p => p.includes('Import.tsx'));
  const hasHistory = Object.keys(pageModules).some(p => p.includes('History.tsx'));
  const hasOutputDemo = Object.keys(pageModules).some(p => p.includes('OutputDemo.tsx'));
  
  if (hasExport) {
    features.push({
      name: 'AI Collaboration Export',
      location: '/export',
      description: 'Generate comprehensive documentation for AI assistants',
      capabilities: [
        'Automatic project structure analysis',
        'Complete tech stack documentation',
        'Component and page documentation',
        'Markdown format for easy copying',
        'Download as .md file',
      ],
      components: ['Export', 'projectAnalyzer'],
    });
  }
  
  if (hasImport) {
    features.push({
      name: 'Project Import',
      location: '/import',
      description: 'Import projects from various sources',
      capabilities: [
        'URL-based import',
        'File upload support',
        'Automatic structure detection',
        'Preview before import',
      ],
      components: ['Import', 'ImportPreviewStep'],
    });
  }
  
  if (hasHistory) {
    features.push({
      name: 'Export/Import History',
      location: '/history',
      description: 'Track all export and import operations',
      capabilities: [
        'Search and filter',
        'Tab navigation',
        'Status indicators',
      ],
      components: ['History'],
    });
  }
  
  if (hasOutputDemo) {
    features.push({
      name: 'Live Project Analysis',
      location: '/output-demo',
      description: 'Real-time analysis of current project structure',
      capabilities: [
        'Dynamic page discovery',
        'Component detection',
        'Route extraction',
        'Feature identification',
        'Tech stack analysis',
      ],
      components: ['OutputDemo', 'projectAnalyzer'],
    });
  }
  
  return features;
}

function analyzeRoutesForExport(): RouteInfo[] {
  const routes: RouteInfo[] = [];
  
  // Dynamically discover routes from pages
  const pageModules = import.meta.glob('/src/pages/*.tsx', { eager: true });
  
  for (const path of Object.keys(pageModules)) {
    const fileName = path.split('/').pop() || '';
    const pageName = fileName.replace('.tsx', '');
    const routePath = pageName === 'Index' ? '/' : 
                     pageName === 'NotFound' ? '*' : 
                     `/${pageName.toLowerCase()}`;
    
    routes.push({
      path: routePath,
      component: pageName,
      protected: false,
    });
  }
  
  return routes.sort((a, b) => {
    if (a.path === '/') return -1;
    if (b.path === '/') return 1;
    if (a.path === '*') return 1;
    if (b.path === '*') return -1;
    return a.path.localeCompare(b.path);
  });
}

function getDependenciesForExport(): Record<string, string> {
  return {
    'react': '^18.3.1',
    'react-dom': '^18.3.1',
    'react-router-dom': '^6.30.1',
    'typescript': '^5.6.0',
    'vite': '^5.4.11',
    'tailwindcss': '^3.4.17',
    '@radix-ui/react-*': 'Various versions',
    'lucide-react': '^0.462.0',
    'sonner': '^1.7.4',
    'zod': '^3.25.76',
  };
}

/**
 * Generates comprehensive markdown documentation for AI collaboration
 */
export function generateAICollaborationDoc(analysis: ProjectAnalysis): string {
  const timestamp = new Date().toLocaleString();
  
  return `# ${analysis.name} - Universal AI Collaboration Document

**Generated:** ${timestamp}
**Purpose:** Complete project context for AI collaboration (ChatGPT, Claude, Lovable, etc.)

---

## Table of Contents
1. [Project Overview](#project-overview)
2. [Technology Stack](#technology-stack)
3. [Architecture](#architecture)
4. [Pages & Routes](#pages--routes)
5. [Component Documentation](#component-documentation)
6. [Key Features](#key-features)
7. [Dependencies](#dependencies)
8. [Development Guidelines](#development-guidelines)
9. [How to Use This Document](#how-to-use-this-document)

---

## Project Overview

### Description
${analysis.description}

### Project Type
Web application built with modern React architecture, focusing on component reusability and type safety.

### Core Technologies
- React 18 with TypeScript
- Vite for blazing-fast development
- Tailwind CSS for styling
- shadcn/ui component library

---

## Technology Stack

### Frontend
${analysis.techStack.frontend.map(item => `- ${item}`).join('\n')}

### Backend
${analysis.techStack.backend.map(item => `- ${item}`).join('\n')}

### AI Integration
${analysis.techStack.ai.map(item => `- ${item}`).join('\n')}

### Database
${analysis.techStack.database.map(item => `- ${item}`).join('\n')}

### Styling & UI
${analysis.techStack.styling.map(item => `- ${item}`).join('\n')}
${analysis.techStack.ui.map(item => `- ${item}`).join('\n')}

---

## Architecture

### Application Structure
\`\`\`
${analysis.architecture.structure}
\`\`\`

### Key Design Patterns
${analysis.architecture.patterns.map(pattern => `- ${pattern}`).join('\n')}

### Data Flow
${analysis.architecture.dataFlow.map((flow, i) => `${i + 1}. ${flow}`).join('\n')}

---

## Pages & Routes

${analysis.pages.map(page => `
### ${page.name}
- **Route:** \`${page.path}\`
- **File:** \`${page.file}\`
- **Description:** ${page.description}
- **Components Used:** ${page.components.join(', ')}
- **Features:**
${page.features.map(f => `  - ${f}`).join('\n')}
`).join('\n')}

---

## Component Documentation

${analysis.components.map(comp => `
### ${comp.name}
- **Location:** \`${comp.path}\`
- **Type:** ${comp.type}
- **Description:** ${comp.description}
- **Props:** ${comp.props.length > 0 ? comp.props.join(', ') : 'None'}
- **Dependencies:** ${comp.dependencies.join(', ')}
`).join('\n')}

---

## Key Features

${analysis.features.map(feature => `
### ${feature.name}
**Location:** \`${feature.location}\`

${feature.description}

**Capabilities:**
${feature.capabilities.map(cap => `- ${cap}`).join('\n')}

**Components:**
${feature.components.map(comp => `- ${comp}`).join('\n')}
`).join('\n')}

---

## Dependencies

Key packages used in this project:

\`\`\`json
${JSON.stringify(analysis.dependencies, null, 2)}
\`\`\`

---

## Development Guidelines

### Code Style
- Use TypeScript for type safety
- Follow React best practices (hooks, functional components)
- Use semantic HTML for accessibility
- Implement proper error handling
- Keep components focused and reusable

### Component Guidelines
1. **Single Responsibility:** Each component does one thing well
2. **Props Over State:** Lift state up when shared
3. **Composition:** Build complex UIs from simple pieces
4. **Error Boundaries:** Catch and handle errors gracefully
5. **Loading States:** Show feedback during async operations

### Performance Best Practices
1. **Code Splitting:** Use dynamic imports for routes
2. **Lazy Loading:** Load components on demand
3. **Memoization:** Use useMemo/useCallback appropriately
4. **Debouncing:** Implement for search/filter inputs

### Common Patterns

#### Toast Notifications
\`\`\`typescript
import { toast } from 'sonner';

// Success
toast.success('Operation successful!');

// Error
toast.error('Something went wrong');

// Info
toast.info('Processing...');
\`\`\`

#### Navigation
\`\`\`typescript
import { useNavigate } from 'react-router-dom';

const navigate = useNavigate();
navigate('/path');
\`\`\`

---

## How to Use This Document with AI Tools

### ChatGPT/Claude/Lovable Collaboration
1. **Paste this entire document** into your conversation
2. **Ask specific questions** like:
   - "How do I add a new feature to [component]?"
   - "What's the best way to implement X given this architecture?"
   - "Help me debug [feature]"
3. **Reference specific sections** for context
4. **Update and re-export** as the project evolves

### AI Assistant Prompts
Use these prompts to get the most out of AI collaboration:

- "Based on this project structure, help me implement [feature]"
- "Review this code for potential issues given the architecture"
- "Suggest improvements to [component] following the patterns used"
- "Help me refactor [component] to follow the component guidelines"

### Best Practices for AI Collaboration
1. **Keep this document updated** - Export regularly as features change
2. **Provide specific context** - Reference exact file paths and component names
3. **Ask for explanations** - Understand the "why" behind suggestions
4. **Validate suggestions** - Always test AI-generated code
5. **Document decisions** - Keep notes on architectural choices

---

**End of Document**
**Last Updated:** ${timestamp}
**Export Version:** 1.0

This document contains complete context about the project structure, components, features, and development patterns. Use it to collaborate effectively with AI assistants for development, debugging, and feature implementation.
`;
}