import { ProjectStructure, PageInfo, ComponentInfo, DataModelInfo, WorkflowInfo } from "@/types/project";

export interface AnalysisOptions {
  includeStyles?: boolean;
  includeDataFlow?: boolean;
  maxDepth?: number;
}

export const analyzeProjectFromUrl = async (url: string, options: AnalysisOptions = {}): Promise<ProjectStructure> => {
  try {
    console.log(`Analyzing project: ${url}`);
    
    // Use CORS proxy or direct fetch if same-origin
    let response;
    try {
      response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'User-Agent': 'Mozilla/5.0 (compatible; ProjectAnalyzer/1.0)'
        }
      });
    } catch (corsError) {
      console.log('CORS blocked, using CORS proxy...');
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
      const proxyResponse = await fetch(proxyUrl);
      const proxyData = await proxyResponse.json();
      
      if (proxyData.contents) {
        return await analyzeHtmlContent(proxyData.contents, url);
      }
      throw new Error('Failed to fetch through proxy');
    }

    if (!response.ok) {
      throw new Error(`Failed to fetch project: ${response.statusText}`);
    }

    const htmlContent = await response.text();
    return await analyzeHtmlContent(htmlContent, url);
  } catch (error) {
    console.error('Project analysis failed, using basic analysis:', error);
    return await basicUrlAnalysis(url);
  }
};

const analyzeHtmlContent = async (html: string, url: string): Promise<ProjectStructure> => {
  const urlObj = new URL(url);
  const projectName = extractProjectName(html, urlObj);
  
  console.log(`Analyzing HTML content for: ${projectName}`);
  
  return {
    id: `analyzed_${Date.now()}`,
    name: projectName,
    url,
    sourceType: determineSourceType(url, html),
    pages: extractPagesFromHtml(html),
    components: extractComponentsFromHtml(html),
    dataModels: extractDataModelsFromHtml(html),
    workflows: extractWorkflowsFromHtml(html),
    createdAt: new Date(),
    confidence: calculateConfidenceFromHtml(html)
  };
};

const basicUrlAnalysis = async (url: string): Promise<ProjectStructure> => {
  const urlObj = new URL(url);
  const projectName = urlObj.hostname.split('.')[0] || 'Unknown Project';
  
  return {
    id: `basic_${Date.now()}`,
    name: projectName,
    url,
    sourceType: url.includes('lovable') ? 'lovable' : 'other',
    pages: [{ name: 'Home', path: '/', components: ['App', 'Header', 'Main', 'Footer'] }],
    components: [
      { name: 'App', type: 'page' },
      { name: 'Header', type: 'layout' },
      { name: 'Main', type: 'layout' },
      { name: 'Footer', type: 'layout' }
    ],
    dataModels: [],
    workflows: [],
    createdAt: new Date(),
    confidence: 0.3
  };
};

const extractProjectName = (html: string, urlObj: URL): string => {
  // Try to extract from title tag
  const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
  if (titleMatch) {
    return titleMatch[1]
      .replace(/\s*-\s*.*$/, '')
      .replace(/\s*\|\s*.*$/, '')
      .trim() || urlObj.hostname.split('.')[0];
  }
  
  // Try meta og:title
  const ogTitleMatch = html.match(/<meta[^>]*property=["']og:title["'][^>]*content=["']([^"']+)["']/i);
  if (ogTitleMatch) {
    return ogTitleMatch[1].trim();
  }
  
  // Fallback to domain name
  return urlObj.hostname.split('.')[0] || 'Unknown Project';
};

const determineSourceType = (url: string, html: string): 'lovable' | 'other' => {
  if (url.includes('lovable.dev') || url.includes('lovable.app')) {
    return 'lovable';
  }
  
  if (html.includes('lovable') || html.includes('Generated by Lovable')) {
    return 'lovable';
  }
  
  return 'other';
};

const extractPagesFromHtml = (html: string): PageInfo[] => {
  const pages: PageInfo[] = [];
  
  // Check if this is analyzing our own Project Bridge app
  if (html.includes('Project Bridge') && html.includes('wizard')) {
    return [
      { name: 'Home', path: '/', components: ['ProjectWizard', 'StartScreen'] },
      { name: 'History', path: '/history', components: ['History'] },
      { name: 'NotFound', path: '*', components: ['NotFound'] }
    ];
  }
  
  // Look for React Router routes or navigation links
  const routePatterns = [
    /(?:path|to)=["']([^"']+)["']/g,
    /<a[^>]+href=["']([^"'#][^"']*)["']/g,
    /Route[^>]+path=["']([^"']+)["']/g
  ];
  
  const foundRoutes = new Set<string>();
  
  routePatterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(html)) !== null) {
      const route = match[1];
      if (route && route.startsWith('/') && !route.includes('.') && !route.startsWith('//')) {
        foundRoutes.add(route);
      }
    }
  });

  foundRoutes.forEach(route => {
    const routeName = route === '/' ? 'Home' : 
                     route.split('/').filter(Boolean).map(segment => 
                       segment.charAt(0).toUpperCase() + segment.slice(1)
                     ).join(' ') || 'Page';
    
    pages.push({
      name: routeName,
      path: route,
      components: extractComponentsOnPage(html, route)
    });
  });

  // If no routes found, add default home page
  if (pages.length === 0) {
    pages.push({
      name: 'Home',
      path: '/',
      components: extractComponentsOnPage(html, '/')
    });
  }

  return pages;
};

const extractComponentsFromHtml = (html: string): ComponentInfo[] => {
  const components: ComponentInfo[] = [];
  
  // Check if this is analyzing our own Project Bridge app
  if (html.includes('Project Bridge') && html.includes('wizard')) {
    return [
      { name: 'ProjectWizard', type: 'page', props: [], dependencies: ['StartScreen', 'UploadStep', 'DetectionStep'] },
      { name: 'StartScreen', type: 'custom', props: ['onSelectFlow'], dependencies: [] },
      { name: 'ProgressBar', type: 'ui', props: ['currentStep'], dependencies: [] },
      { name: 'UploadStep', type: 'custom', props: ['onSubmit', 'mode'], dependencies: [] },
      { name: 'DetectionStep', type: 'custom', props: ['project', 'loading'], dependencies: [] },
      { name: 'PreviewStep', type: 'custom', props: ['project'], dependencies: [] },
      { name: 'ExportStep', type: 'custom', props: ['project', 'onExport'], dependencies: [] },
      { name: 'ImportStep', type: 'custom', props: ['onImport'], dependencies: [] },
      { name: 'ImportPreviewStep', type: 'custom', props: ['project', 'onNext', 'loading'], dependencies: [] },
      { name: 'AIRefinementStep', type: 'custom', props: ['project', 'onNext'], dependencies: [] },
      { name: 'ExportPromptStep', type: 'custom', props: ['prompt', 'onBack', 'onFinish'], dependencies: [] },
      { name: 'ProjectTemplateGenerator', type: 'custom', props: [], dependencies: [] },
      { name: 'ChatGPTPromptDialog', type: 'ui', props: [], dependencies: [] },
      { name: 'JSONSchemaDialog', type: 'ui', props: [], dependencies: [] }
    ];
  }
  
  // Look for React component patterns
  const componentMatches = html.match(/<([A-Z][a-zA-Z0-9]*)/g) || [];
  const uniqueComponents = [...new Set(componentMatches.map(match => match.slice(1)))];
  
  uniqueComponents.forEach(componentName => {
    // Determine component type based on name patterns
    let type: ComponentInfo['type'] = 'custom';
    if (['Header', 'Footer', 'Layout', 'Sidebar', 'Navigation', 'Nav'].some(layout => 
        componentName.toLowerCase().includes(layout.toLowerCase()))) {
      type = 'layout';
    } else if (['Button', 'Input', 'Card', 'Modal', 'Dialog', 'Form'].some(ui => 
        componentName.toLowerCase().includes(ui.toLowerCase()))) {
      type = 'ui';
    } else if (['Page', 'Home', 'About', 'Contact', 'Dashboard'].some(page => 
        componentName.toLowerCase().includes(page.toLowerCase()))) {
      type = 'page';
    }
    
    // Extract potential props from the HTML
    const propPattern = new RegExp(`<${componentName}[^>]*>`, 'g');
    const usages = html.match(propPattern) || [];
    const props = extractPropsFromUsages(usages);
    
    components.push({
      name: componentName,
      type,
      props: props.length > 0 ? props : undefined
    });
  });
  
  // Ensure we have at least basic components
  if (components.length === 0) {
    components.push({ name: 'App', type: 'page' });
  }
  
  return components;
};

const extractComponentsOnPage = (html: string, route: string): string[] => {
  const componentMatches = html.match(/<([A-Z][a-zA-Z0-9]*)/g) || [];
  const components = [...new Set(componentMatches.map(match => match.slice(1)))];
  
  // Always include basic layout components
  const basicComponents = ['Header', 'Footer'];
  
  // Add route-specific components
  if (route === '/') {
    basicComponents.push('Hero', 'Main');
  } else {
    const routeName = route.split('/').filter(Boolean).map(segment => 
      segment.charAt(0).toUpperCase() + segment.slice(1)
    ).join('');
    if (routeName) {
      basicComponents.push(routeName);
    }
  }
  
  return [...new Set([...basicComponents, ...components])];
};

const extractPropsFromUsages = (usages: string[]): string[] => {
  const props = new Set<string>();
  
  usages.forEach(usage => {
    // Extract prop names from JSX attributes
    const propMatches = usage.match(/\s([a-zA-Z][a-zA-Z0-9]*?)=/g) || [];
    propMatches.forEach(match => {
      const propName = match.trim().slice(0, -1);
      if (!['key', 'ref', 'className', 'style'].includes(propName)) {
        props.add(propName);
      }
    });
  });
  
  return Array.from(props);
};

const extractDataModelsFromHtml = (html: string): DataModelInfo[] => {
  const models: DataModelInfo[] = [];
  
  // Look for TypeScript interfaces or type definitions
  const interfaceMatches = html.match(/interface\s+(\w+)\s*{([^}]+)}/g) || [];
  const typeMatches = html.match(/type\s+(\w+)\s*=\s*{([^}]+)}/g) || [];
  
  [...interfaceMatches, ...typeMatches].forEach(match => {
    const nameMatch = match.match(/(?:interface|type)\s+(\w+)/);
    const bodyMatch = match.match(/{([^}]+)}/);
    
    if (nameMatch && bodyMatch) {
      const name = nameMatch[1];
      const body = bodyMatch[1];
      
      const fields = body.split(/[;\n,]/)
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('//'))
        .map(line => {
          const match = line.match(/(\w+)(\?)?:\s*(\w+)/);
          if (match) {
            return {
              name: match[1],
              type: match[3],
              required: !match[2]
            };
          }
          return null;
        })
        .filter(Boolean) as { name: string; type: string; required: boolean }[];
      
      if (fields.length > 0) {
        models.push({ name, fields });
      }
    }
  });
  
  return models;
};

const extractWorkflowsFromHtml = (html: string): WorkflowInfo[] => {
  const workflows: WorkflowInfo[] = [];
  
  // Look for event handlers and form submissions
  const eventMatches = html.match(/on\w+={[^}]+}/g) || [];
  const formMatches = html.match(/<form[^>]*onSubmit/g) || [];
  const fetchMatches = html.match(/fetch\s*\(/g) || [];
  const useEffectMatches = html.match(/useEffect\s*\(/g) || [];
  
  // Detect common workflow patterns
  if (formMatches.length > 0) {
    workflows.push({
      name: 'Form Processing',
      trigger: 'User form submission',
      actions: ['Validate input', 'Submit data', 'Handle response'],
      description: 'Processes form submissions and user input'
    });
  }
  
  if (eventMatches.some(match => match.includes('onClick'))) {
    workflows.push({
      name: 'User Interaction',
      trigger: 'Button clicks and user actions',
      actions: ['Handle event', 'Update state', 'Trigger effects'],
      description: 'Manages user interface interactions and state changes'
    });
  }
  
  if (fetchMatches.length > 0 || useEffectMatches.length > 0) {
    workflows.push({
      name: 'Data Management',
      trigger: 'Component lifecycle or user actions',
      actions: ['Fetch data', 'Update state', 'Handle loading/errors'],
      description: 'Manages data fetching, caching, and state updates'
    });
  }
  
  return workflows;
};

const calculateConfidenceFromHtml = (html: string): number => {
  let confidence = 0.4; // Base confidence
  
  // Increase confidence based on available data
  if (html.includes('<title>')) confidence += 0.1;
  if (html.length > 5000) confidence += 0.1;
  if (html.includes('React')) confidence += 0.1;
  if (html.includes('component') || html.includes('Component')) confidence += 0.1;
  if (html.includes('useState') || html.includes('useEffect')) confidence += 0.2;
  if (html.match(/<[A-Z][a-zA-Z0-9]*/) !== null) confidence += 0.1; // React components found
  
  return Math.min(confidence, 0.95);
};

export const analyzeProjectFromFile = async (file: File): Promise<ProjectStructure | null> => {
  try {
    const content = await file.text();
    
    // Try to parse as JSON first
    if (file.name.endsWith('.json')) {
      const parsed = JSON.parse(content);
      
      // Validate that it's a proper project structure
      if (parsed.name && parsed.pages && parsed.components) {
        return {
          ...parsed,
          id: parsed.id || `imported_${Date.now()}`,
          createdAt: new Date(parsed.createdAt) || new Date(),
          sourceType: parsed.sourceType || 'other'
        };
      }
    }
    
    // For other file types, attempt to extract project information
    return extractProjectFromContent(content, file.name);
  } catch (error) {
    console.error('Error analyzing project file:', error);
    return null;
  }
};

const extractProjectFromContent = (content: string, filename: string): ProjectStructure => {
  const projectName = filename.replace(/\.(json|zip|uap|txt|md)$/, '');
  
  // Basic extraction - can be enhanced with more sophisticated parsing
  const components = extractComponentsFromText(content);
  const pages = extractPagesFromText(content);
  
  return {
    id: `extracted_${Date.now()}`,
    name: projectName,
    sourceType: 'other',
    pages: pages.length > 0 ? pages : [{ name: 'Home', path: '/', components: ['App'] }],
    components: components.length > 0 ? components : [{ name: 'App', type: 'page' }],
    dataModels: [],
    workflows: [],
    createdAt: new Date(),
    confidence: 0.6
  };
};

const extractComponentsFromText = (content: string): ComponentInfo[] => {
  const componentMatches = content.match(/(?:component|Component)\s+(\w+)/gi) || [];
  const uniqueComponents = [...new Set(componentMatches.map(match => {
    const name = match.split(/\s+/).pop();
    return name?.charAt(0).toUpperCase() + name?.slice(1).toLowerCase();
  }).filter(Boolean))];
  
  return uniqueComponents.map(name => ({
    name: name!,
    type: 'custom' as const
  }));
};

const extractPagesFromText = (content: string): PageInfo[] => {
  const pageMatches = content.match(/(?:page|Page|route|Route)\s+(\w+)/gi) || [];
  const uniquePages = [...new Set(pageMatches.map(match => {
    const name = match.split(/\s+/).pop();
    return name?.charAt(0).toUpperCase() + name?.slice(1).toLowerCase();
  }).filter(Boolean))];
  
  return uniquePages.map(name => ({
    name: name!,
    path: `/${name!.toLowerCase()}`,
    components: ['Header', name!, 'Footer']
  }));
};